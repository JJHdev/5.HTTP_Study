1. HTTP API를 만들어 보자
  -. API를 설계할때에는 리소스를 중요하게 생각하고 해야한다.
  -. 회원을 등록하고 수정하고 조회하는게 리소스가 아니라, 회원이라는것 자체가 리소스다.
  -. 회원을 등록하고, 수정, 조회하는것을 배제하고, 회원이라는 리소스만  만 식별하면된다. 

  -. 회원목록조회 /members/
  -. 회원 조회 /members/{id}
  -. 회원 등록 /members/{id}
  -. 회원 수정 /members/{id}
  -. 회원 삭제 /members/{id}

  -> 이것을 구분하는것은 GET, POST, PUT, Patchm, Delete 로 구분하는것이다.
  -. 리소스와 행위를 분리하고 리소스만 식별하는 것이다.
  -. 실제로 리소스만으로 URI를 만드는게 좋은데 그게 안되어 컨트롤 URI를 사용할수도 있다. (100번 고객의 배달 시작요청 같이) start-delivery)
  
2. HTTP 메서드 -GET, POST
  -. GET (리소스 조회)
    -. 서버에 전달하고 싶은 데이터는 쿼리로 전달
    -. 메시지 바디를 통해서 데이터를 전달할수 있지만 지원하지 않는 곳이 많아서 권장하지 않음.

  -. POST (요청 데이터 처리, 주로 등록에사용)
    -. 메시지 바디를 통해 서버로 요청 데이터 전달
    -. 서버는 요청 데이터를 처리 (메시지 바디를 통해 들어온 데이터를 처리하는 모든 기능을 수행한다.)
    -. 주로 전달된 데이터로 신규 리소스 등록, 프로세스 처리에 사용

  -. 조회할때에는 GET, 등록할때에는 POST (조회시 JSON으로 데이터 넘겨야하는데 GET을 지원 안할수도 있어 POST를 사용할수도 있음)
     하는데 이는 GET을 사용할 경우 캐싱을 하여 조회 성능을 유리하게 만드는데, POST에서는 캐싱하기 어렵다.

3. HTTP 메서드 - Put, Patch, Delete
  -. PUT (리소스를 대체, 해당 리소스가 없으면 생성)
    -. 리소스가 있으면 대체, 리소스가 없으면 생성 (쉽게 이야기하면 덮어버림)
    -. 클라이언트의 PUT은 정확한 URL를 알아야한다. (리소스의 식별자)
    -. username, age가 2개 있는데 이미 값이 있다. 그런데 age만 보내면 username은 없는걸로 대체된다. (아예 리소스 100번의 값을 대체해버린다.)
      
  -. Patch (리소스 부분 변경)
    -. 리소스를 부분으로만 변경한다.
    -. PUT에서는 아예 대체해버리니 age 50을 보낼경우 userName은 변경안되고, age만 변경된다. 
    -. 간혹가다가 HTTP에서 서버중 적용이 안되는 경우도 있다. 이럴 경우 POST를 이용한다.
    
  -. Delete (리소스 삭제)
    -. 리소스를 아예 삭제한다. 
    

4. HTTP 메서드의 속성
  -. 안전, 멱등, 캐시가능
  -. 안전 (호출해도 리소스가 변경하지 않는다.)
    -. (GET은 안전하다 조회하다보니) , (PUT DELETE, POST등 데이터가 변하니 안전하지 않다.)
  
  -. 멱등 (한번 , 두번, 100번 호출하든 결과가 똑같다.)
    -. (GET, PUT, DELETE는 여러번 호출해도 결국 같은 요청시 결과 값이 같다.), (POST 두번 호출시 같은 결제가 중복해서 발생할수 있다.)
    -. 멱등은 왜 필요할까?? 클라이언트의 호출과 서버의 응답에서 서버의 응답이 없을 경우 클라이언트에서 다시 호출할지 안할지(자동 복구 메커니즘) 판단할 경우 멱등을 기준으로 한다.
    -. 왜냐하면 멱등은 여러번 호출하여도 결국 결과는 같으니까.
    -. 멱등은 외부 요인으로 중간에 리소스가 변경되는 것 까지는 고려하지는 않는다.

  -. 캐시가능
    -. 응답 결과 리소스를 캐시해서 사용해도 되는가?
    -. GET, HEAD, POST, PATCH 캐시가능
    -. 실제로는 GET, HEAD 정도만 캐시로 사용
      -. 그이유로는 캐시를 사용 할려면 결국 키값까지 같아야 한다 ,근데 POST는 messageBody를 사용하는데 여기에서 key,value가 동일하기 힘들어서 이다.
