1. 모든것이 HTTP(Hyper Text Transfer Protocol)
  -. HTML, TEXT, Image, 음성, 영상, 파일, JSON, XML, API, 서버간의 데이터 전송
  -. TCP: HTTP/1.1 , HTTP/2
  -. UDP: HTTP/3

  -. 클라이언트 서버 구조
  -. 무상태 프로토콜, 비연결성
  -. HTTP메시지
  -. 단순함, 확장 가

2. 클라이언트 서버 구조
  -. Request, Response 구조
  -. 클라이언트는 서버에 요청을 보내고, 응답을 대기
  -. 서버가 요청에 대한 결과를 만들어서 응답

3. stateful, stsateless
  -. 무상태 프로토콜 (스테이스리스) stateless
  -. stateful VS stateful
    -. stateful은 노트북 얼마인지? > 2개 구매 (노트북이라고 알고있음)
    -. stateless은 노트북 얼마인지? > 2개 구매 (노트북이라는것을 모름)

  -. 즉 서버가 클라이언트의 상태 정보를 유지하지않는것 (stateless)
    -. 항상 요청으로만 온것으로만 판단한다.

  -. 상태유지 : 중간에 다른 점원으로 바뀌면 안된다.
  -. 무상태 : 중간에 다른 점원으로 바뀌어도 된다.
    -. 갑자기 고객이 증가해도 점원을 대거 투입 할수 있다.
    -. 갑자기 클라이언트 요청이 증가해도 서버를 대거 투입할 수 있다.
  -. 무상태는 응답 서버를 쉽게 바꿀 수 있다. >> 무한한 서버 증설 가능

  -. 실무 한계 (stateless)
    -. 로그인이 필요 없는 단순한 서비스 소개 화면 (무상태)
    -. 상태를 유지필요 (로그인 >> 상태를 유지해야한다.) > 브라우저의 쿠키, 세션을 사용해서 상태 유지
    -. 즉 상태 유지는 최소한만 사용해야한다. (데이터와 용량을 많이 잡아먹어서)

4. 비연결성
  -. 클라이언트가 요청하고 서버는 응답하고 바로 연결이 끊어진다. 그러면 서버의 자원을 최소한으로만 사용이 가능해진다.
  -. HTTP는 기본이 연결을 유지하지 않는 모델
  -. 일반적으로 초 단위의 이하의 빠른 속도로 응답
  -. 서버 자원을 매우 효율적으로 사용할 수 있음

  -. 단점
    -. TCP/IP 연결을 새로 맺어야 함 -3 way handshake 시간 추가
    -. HTML과 자바스크립트, css , 이미지, 수많은 자원들 받음
    -. 지금은 HTTP 지속 연결로 문제 해결 

5. HTTP 메시지
  -. 모든 데이터를 주고 받을때 HTTP를 이용한다.
  -. HTTP 요청메시지,  HTTP응답 메시지 서로 다르게 양식이 설계되어있다.

  -. HTTP 메시지 구조
    -. 시작라인 (start-line)
    -. 헤더     (header)
    -. 공백라인 (empty line) CRLF
    -. 메시지바디 (message body)

  -. HTTP요청메시지
    -. 시작라인 (get /파라미터 HTTP 버전)
    -. 헤더     (filed-name ":" OWS field-value OWS)
    -. 공백라인
    -. messagebody가 있으면 넣고 없을경우 생략

  -. HTTP응답메시지
    -. 시작라인 (HTTP버전 응답코드)
    -. 헤더   (콘텐트타입, 콘텐트길이)
    -. 공백라인
    -. 메시지바디 (html)

  -. HTTP 헤더에는 HTTP 전송에 필요한 모든 부가정보 (메시지바디의 내용, 메시지 바디의 크기, 압축, 인증, 클라이언트 정보, 서버 애플리케이션정보, 캐시 관리정보)
  -. HTTP 메시지바디에는 실제 전솔할 데이터 (HTML, 이미지, 영상, JSON, byte) 


